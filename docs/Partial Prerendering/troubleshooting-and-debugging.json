{
  "title": "Next.js Partial Prerendering 故障排除與調試指南",
  "version": "Next.js 15+",
  "description": "常見 PPR 問題的解決方案、調試工具和錯誤處理策略",
  "metadata": {
    "category": "Troubleshooting",
    "complexity": "Medium",
    "usage": "問題診斷、錯誤修復、調試工具、最佳實踐",
    "lastmod": "2025-01-17",
    "source": "Vercel Next.js Official Documentation"
  },
  "common_issues": {
    "prerender_errors": {
      "description": "預渲染過程中出現的錯誤",
      "causes": [
        "動態 API 在預渲染時被訪問",
        "不穩定的緩存回調",
        "同步訪問請求數據",
        "Math.random() 或 Date.now() 在預渲染時使用"
      ],
      "solutions": [
        "使用 Suspense 包裝動態組件",
        "實現適當的緩存策略",
        "使用 connection() 排除預渲染",
        "緩存隨機值或時間相關數據"
      ]
    },
    "hydration_mismatches": {
      "description": "服務器端和客戶端渲染不匹配",
      "causes": [
        "客戶端組件在 SSR 時訪問瀏覽器 API",
        "隨機值在服務器端和客戶端不同",
        "時間相關數據不一致"
      ],
      "solutions": [
        "使用 Suspense 包裝客戶端組件",
        "實現安全的隨機值生成",
        "緩存時間相關數據"
      ]
    },
    "dynamic_rendering_issues": {
      "description": "動態渲染相關問題",
      "causes": [
        "未正確使用 Suspense 邊界",
        "動態 API 訪問模式不當",
        "searchParams 處理錯誤"
      ],
      "solutions": [
        "檢查 Suspense 邊界放置",
        "優化動態 API 訪問模式",
        "正確處理異步 searchParams"
      ]
    }
  },
  "debugging_tools": {
    "next_build_debug": {
      "command": "next build --debug-prerender",
      "description": "啟用預渲染調試輸出",
      "features": [
        "禁用服務器代碼壓縮",
        "啟用源映射",
        "第一個錯誤後繼續構建",
        "詳細的預渲染錯誤信息"
      ],
      "usage": "僅用於開發環境，不應在生產構建中使用"
    },
    "console_logging": {
      "description": "使用 console.log 調試預渲染問題",
      "best_practices": [
        "在關鍵組件中添加日誌",
        "記錄動態 API 訪問",
        "監控 Suspense 邊界行為"
      ]
    },
    "browser_devtools": {
      "description": "使用瀏覽器開發者工具調試",
      "features": [
        "Network 標籤監控流式傳輸",
        "Console 標籤查看錯誤",
        "Elements 標籤檢查 DOM 結構"
      ]
    }
  },
  "error_solutions": {
    "ppr_caught_error": {
      "description": "PPR 捕獲錯誤的解決方案",
      "solution": "在 try/catch 塊之前調用 unstable_noStore()",
      "code_example": {
        "before": "async function fetchData() {\n  try {\n    const response = await fetch(url);\n    ...\n  } catch (x) {\n    ...\n  }\n}",
        "after": "import { unstable_noStore } from 'next/cache'\n\nasync function fetchData() {\n  unstable_noStore() // 在 try/catch 之前選擇退出\n  try {\n    const response = await fetch(url);\n    ...\n  } catch (x) {\n    ...\n  }\n}"
      }
    },
    "missing_suspense": {
      "description": "缺少 Suspense 邊界的解決方案",
      "solution": "為使用 connection() 的組件添加 Suspense 邊界",
      "code_example": {
        "tsx": "import { Suspense } from 'react'\nimport { connection } from 'next/server'\n\nasync function DynamicComponent() {\n  await connection()\n  return <div>Dynamic content</div>\n}\n\nexport default function Page() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <DynamicComponent />\n    </Suspense>\n  )\n}"
      }
    },
    "dynamic_metadata": {
      "description": "動態元數據問題的解決方案",
      "solution": "使用 'use cache' 指令或 Suspense 邊界",
      "code_example": {
        "caching_solution": "export async function generateMetadata() {\n  'use cache'\n  const { title } = await cms.getPageData('/.../page')\n  return { title }\n}",
        "suspense_solution": "export default function RootLayout({ children }) {\n  return (\n    <Suspense>\n      <html>\n        <body>{children}</body>\n      </html>\n    </Suspense>\n  )\n}"
      }
    }
  },
  "prevention_strategies": {
    "code_organization": "組織代碼以最大化靜態內容",
    "api_access_patterns": "優化動態 API 訪問模式",
    "suspense_strategy": "戰略性使用 Suspense 邊界",
    "caching_implementation": "實現適當的緩存策略",
    "testing_approaches": "建立全面的測試策略"
  },
  "monitoring_and_alerting": {
    "error_tracking": "實施錯誤追蹤和監控",
    "performance_monitoring": "監控 PPR 性能指標",
    "user_experience_tracking": "追蹤用戶體驗指標",
    "alert_systems": "建立自動化警報系統"
  }
}
